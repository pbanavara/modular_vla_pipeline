import mujoco
import mujoco.viewer
import numpy as np
import time
from scipy.optimize import minimize
from scipy.spatial.transform import Rotation as R
from log.setup_logger import setup_logger

class MuJoCoExecutor:
    """
    A class for executing actions generated by the planner in MuJoCo environments.
    """
    def __init__(self, model_path, action_json):
        self.logger = setup_logger("MuJoCoExecutor")
        print(f"Loading model from: {model_path}")
        self.model = mujoco.MjModel.from_xml_path(model_path)
        self.data = mujoco.MjData(self.model)
        self.model = mujoco.MjModel.from_xml_path(model_path)
        self.data = mujoco.MjData(self.model)
        self.joint_names = []
        for joint_id in range(self.model.njnt):
            name = mujoco.mj_id2name(self.model, mujoco.mjtObj.mjOBJ_JOINT, joint_id)
            self.joint_names.append(name)
        self.last_action_state = None
        # --- Joint groupings ---
        self.left_arm_joints = [name for name in self.joint_names if name.startswith("left/")]
        self.right_arm_joints = [name for name in self.joint_names if name.startswith("right/")]

        self.left_joint_ids = [self.model.joint(name).qposadr 
                               for name in self.left_arm_joints]
        self.eft_joint_ids = [int(i) for i in self.left_joint_ids]
        self.right_joint_ids = [self.model.joint(name).qposadr 
                                for name in self.right_arm_joints]
        self.right_joint_ids = [int(i) for i in self.right_joint_ids]

        self.plan = action_json
    
    def move_through_trajectory(self, gripper, arm_joints, trajectory, viewer):

        joint_ids = [mujoco.mj_name2id(self.model, 
                                       mujoco.mjtObj.mjOBJ_JOINT, name)
                    for name in arm_joints]
        if self.last_action_state is not None:
            self.logger.info("Overriding sim with the last action state")
            for i, joint_name in enumerate(arm_joints):
                joint_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, joint_name)
                qpos_index = self.model.jnt_qposadr[joint_id]
                self.data.qpos[qpos_index] = self.last_action_state[i]
            # Setting the velocisity and acceleration to zero explicitly
            self.data.qvel[:] = 0
            self.data.qacc[:] = 0
            mujoco.mj_forward(self.model, self.data)

        q_guess = np.array([
            self.data.qpos[self.model.jnt_qposadr[jid]]
            for jid in joint_ids
            ], dtype=float)
        self.logger.info(f"Solving IK for initial state: {q_guess} ")
        # Temporary hack to get the arm to move to the plate
        plate_site_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_SITE, "plate")
        plate_pos = self.data.site_xpos[plate_site_id].copy()
        print("üçΩ Plate position:", plate_pos)
        for step in trajectory:
            pos = np.array(step["position"])
            #rot = np.array(step["rotation"])
            rot = None 
            self.logger.info(f"Updated persistent joint state: {self.last_action_state}")
            # Solve from current joint state
            self.logger.info(f"Solving IK for remaining state: {q_guess} ")
            current_sim_qpos = np.array([
                self.data.qpos[self.model.jnt_qposadr[jid]]
                    for jid in joint_ids
                ])
            self.logger.info(f"Sim qpos before solve: {current_sim_qpos} and last action state {self.last_action_state}")
            q_solution = self.solve_ik(gripper, 
                                       arm_joints, pos, rot, q_init=q_guess)

            # Apply solution to joints
            for i, joint_name in enumerate(arm_joints):
                joint_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, joint_name)
                qpos_index = self.model.jnt_qposadr[joint_id]
                self.data.qpos[qpos_index] = q_solution[i]
                actuator_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_ACTUATOR, joint_name)
                self.data.ctrl[actuator_id] = q_solution[i]

            print("Actuator ctrl before stepping:", self.data.ctrl[:])
            mujoco.mj_forward(self.model, self.data)

            # Simulate to see movement
            for _ in range(100):  # could be based on trajectory delta
                mujoco.mj_step(self.model, self.data)
                viewer.sync()
                time.sleep(0.01)
            
            for alpha in np.linspace(0, 1, 20):
                ctrl_interp = (1 - alpha) * q_guess + alpha * q_solution
                for i, joint_name in enumerate(arm_joints):
                    actuator_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_ACTUATOR, joint_name)
                    self.data.ctrl[actuator_id] = ctrl_interp[i]

                mujoco.mj_step(self.model, self.data)
                viewer.sync()
                time.sleep(0.01)
            #Persist joint state
            q_guess = q_solution.copy()
            self.last_action_state = q_solution.copy()
            viewer.sync()

    def solve_ik(self, gripper_site, 
                 gripper_joints, 
                 target_pos, 
                 target_rot,
                 q_init=None):
        """
        Inverse kinematics solver using L-BFGS-B to minimize position and optional rotation error.

        Args:
            gripper_site (str): Name of the end-effector site in the MuJoCo model.
            gripper_joints (list): List of joint names controlling the arm.
            target_pos (np.ndarray): Desired XYZ position in world coordinates.
            target_rot (np.ndarray or None): Desired Euler XYZ rotation in radians (or None for position-only IK).

        Returns:
            np.ndarray: Optimal joint angles for the given target.
        """
        # TODO: REmove this target_rot = None. This is a hack until we can figure out why rotations cause the arm not to move.
        self.logger.info(f"Solving IK for target pos: {target_pos} and rot {target_rot}")   
        site_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_SITE, gripper_site)
        joint_ids = [int(self.model.joint(name).qposadr) for name in gripper_joints]
        def fk(qpos):
            # Create an isolated copy of data
            temp_data = mujoco.MjData(self.model)
            temp_data.qpos[:] = self.data.qpos[:]  # start with current sim state

            for i, j in enumerate(joint_ids):
                temp_data.qpos[j] = qpos[i]

            mujoco.mj_forward(self.model, temp_data)

            pos = temp_data.site_xpos[site_id].copy()
            rot_euler = None
            if target_rot is not None:
                rot_mat = temp_data.site_xmat[site_id].reshape(3, 3).copy()
                rot_euler = R.from_matrix(rot_mat).as_euler("xyz")
            return pos, rot_euler

        def rotation_error(rot_vec, target_vec):
            R1 = R.from_euler('xyz', rot_vec).as_matrix()
            R2 = R.from_euler('xyz', target_vec).as_matrix()
            R_err = R1.T @ R2
            angle = np.arccos(np.clip((np.trace(R_err) - 1) / 2, -1.0, 1.0))
            return angle

        def cost_fn(qpos):
            pos, rot = fk(qpos)
            pos_error = np.linalg.norm(pos - target_pos)
            if target_rot is not None and rot is not None:
                rot_error = rotation_error(rot, target_rot)
                return float(pos_error + 0.5 * rot_error)
            else:
                return float(pos_error)

        bounds = [
            tuple(self.model.jnt_range[self.model.joint(name).id])
            for name in gripper_joints
        ]
        result = minimize(cost_fn, q_init, method="L-BFGS-B", bounds=bounds)
        if not result.success:
            raise RuntimeError(f"IK solver failed: {result.message}")
        return result.x
    
    def run(self):
        with mujoco.viewer.launch_passive(
                self.model, self.data 
        ) as viewer:
            for action in self.plan:
                arm = action.get("arm", "left")
                if action["trajectory"]:
                    if action["action"] == "move_to_pose": 
                        if arm == "right": #Robot specific definition
                            self.move_through_trajectory("left/gripper", 
                                             self.left_arm_joints,
                                             action["trajectory"], viewer)
                        else:
                            qpos_snapshot = np.array([
                                        self.data.qpos[self.model.jnt_qposadr[
                                                mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, name)
                                                ]] for name in self.left_arm_joints
                                            ])
                            print(f"[üö®] QPOS before new action: {qpos_snapshot}")
                            self.move_through_trajectory("left/gripper", 
                                             self.left_arm_joints,
                                             action["trajectory"], viewer)
                else:
                    self.logger.info("No trajectory ‚Äî skipping")
                self.logger.info(f"Completed Action: {action}")
            # This is to preserve the mujoco without quitting the viewer
            while viewer.is_running():
                viewer.sync()
